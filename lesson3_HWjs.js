/*  ДЗ 3. Робота з типами данних
Створіть свій власний репозиторій.
В ньому створіть гілку js_homework1 (кожна наступна домашня робота буде здійснюватись в окремій гілці).
Вам необхідно вказати, яким буде результат операції та описати крок за кроком у вигляді коментарів, як відбувається перетворення в кожному прикладі:  
 */
1)  'number' + 3 + 3  
//  спрацює конкатинація (склеювання), до number додасться 3 - отримуємо 'number3'. І потім знову спрацює конкатинація і буде 'number33'

2) null + 3
//  приводимо null до числа - це буде 0. 0+3 = 3 

3)  5 && "qwerty"
//  отримуємо 'qwerty', бо 5 - це true, 'qwerty'- true/ Дійшли до кінця, тому повертається останнє значення true


4)  +'40' + +'2' + "hillel";
/* унарний плюс перетворює рядок у число, тому отримуємо 40. Біля '2' також є унарний плюс, тому стрінга стає числом. Виходить 40+2+"hillel". Тут спрацьовує конкатинація з плюсом і рядком 
Отримуємо '42hillel' */

5)  '10' - 5 === 6;
/* арифметичні оператори, в даному випадку мінус, намагаються перетворити стрінгу у число. Отримуємо 10-5 = 5
Далі виконується строга рівність, 5 !==6, томк отримуємо false */

6)  true + false
// тут буде 1. true і false приводяться до чисел. true приводиться до 1, false - до 0. 1+0=1

7)  '4px' - 3
// тут буде Nan - not a numder. Мінус намагається перетворити стрінгу у число. В даному випадку це не можливо. 

8)  '4' - 3
//  тут буде 1. Бо математичні оператори намагаються привести стрінгу до числа. В даному випадку це можливо. Буде 4-3 = 1

9)  '6' + 3 ** 0;
 /* спочатку підносимо 3 в 0-ву степінь - це 1. Далі спрацьовує конкатинація з плюсом і рядком.
 Отримуємо '61' */

10)  12 / '6'
//  знак ділення перетворює рядок на число. Отримуємо 12/6 = 2

11)  '10' + (5 === 6);
/* спочатку дивимось, що в дужках. там строге порівняння, коли порвнюється нк тільки значення, а й тип. 5 !== 6, тому у дужках буде false. Далі спрацьовує конкатинація з плюсом 
і рядком (склеювання). Отримужмо '10false'
 */

12)  null == ''
//  буде false. null рівний тільки undefined і null у нестрогому порівнянні.  Все решта - false 

13)  3 ** (9 / 3);
//  спочатку дія в дужках. Отримуємо 3. Далі підносимо 3 у 3тю степінь. Буде 27

14)  !!'false' == !!'true'
/* !! -подвійне заперечення. стрінга- це завжди true.Ліва частина: перший знак ! перетворює стрінгу (true) у false, другий знак ! перетворює false y true. Права частина - та ж логіка,
тільки навпаки. Тому на виході маємо true == true. Отримуємо true
 */
15)  0 || '0' && 1
 /* дивимось на праву частину. повинні виконуватися дві умови. стрінга це true, 1 - true - дійшли до кінця - виводимо останнє значення true - це 1.
 тепер оператор   порівн  яння - хоча б одне значення має бути true. 0 - false - йдем далі - 1- true. Виводимо 1  */

16)  (+null == false) < 1;
//  +null - приводиться до числа - буде 0. 0 == false ? - дорівнює, тому отримуємо true. true <1 ? - ні, бо true - це 1, а 1 не менше 1. Тому на виході буде false

17)  false && true || true
/* спочатку виконуємо ліву частину з логічним І. Отримуємо false, для true має виконуватися обидві умови.І
Далі порівнюємо - має виконатись хоча б одна умова - повернути true. Така умова є, тому на виході отримуємо true
 */
18)  false && (false || true);
//спочатку в дужках - поверне true. Потім повинні виконатись обидві умови. Перша умова - fasle - виходимо і повертаємо fasle

19)  (+null == false) < 1 ** 5;
 /* +null - приводиться до числа - буде 0. 0 == false ? - дорівнює, тому отримуємо true. 1 у 5 степені все одно 1. true <1 ? - ні, бо true - це 1, а 1 не менше 1. 
 Тому на виході буде false
 */

